# Вывод графика переходного процесса на светодиодную матрицу p10 при помощи двух плат
Задачи: 
1. 	Реализовать расчёт графика переходного процесса на одной из плат
2.	Обеспечить передачу расчётных данных между платами по интерфейсу I2C
3.	Обеспечить вывод графика переходного процесса при помощи другой платы на светодиодную матрицу по интерфейсу SPI
   ХОД РАБОТЫ
В данной работе главной задачей является вывод переходного процесса на светодиодную матрицу P10, имеющей разрешение 16x32 светодиода 

![matrixp10](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/40c7b4b3-7ce0-45f5-ad90-0d4fdaac1d0a)

Матрица имеет разъём 16pin, для подключения используются следующие пины:

A и B –  контакты мультиплексирования, задают, какая из 4 групп светодиодов экрана работает в данный момент

nOE – разрешение работы матрицы

CLK — линия синхронизации

R — линия данных 

SCLK – линия для защёлкивания переданных в сдвиговые регистры данных на их выходы

![pins](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/b0a6d6d8-1f05-4bdc-8180-e0e8813501bf)

Необходимо реализовать расчёт необходимых данных на одной плате и вывод этих данных при помощи другой платы. Соответственно, одна из плат будет использоваться в режиме Master, и другая плата в режиме Slave.
Master и Slave - это режимы работы, которые позволяют организовать обмен данными между двумя или более микроконтроллерами.
Один микроконтроллер настраивается как мастер, а остальные - как слейвы. Мастер управляет обменом, генерирует синхросигналы и указывает слейвам, когда передавать или принимать данные.
Обмен осуществляется по специальным протоколам, в данной работе используется протокол I2C для передачи данных между микроконтроллерами и SPI для 
отправки данных на матрицу.

Первым этапом работы является настройка обеих плат в среде CubeMX. Для этого в среде CubeMX необходимо открыть окно выбора плат "MCU SELECTOR"

![image](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/60204988-8539-483b-b69b-8d916c203d81)

Далее в открывшемся окне нужно найти и выбрать требуемую плату.
![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/9d4141d9-0255-4146-aa26-07f4b3aef942)

Проведём настройку платы Slave, на которой будут проводиться необходимые расчёты. 
В открывающемся списке System core -> SYS -> Debug выберем Serial Wire для возможности отладки и программирования микроконтроллера с помощью внешнего отладчика/программатора.
Далее в System core -> RCC -> High Speed Clock (HSE) выберем Crystal/Ceramic Resonator, тем самым выбрав внешний керамический резонатор 
для генерации высокостабильного тактового сигнала, который нужен микроконтроллеру. 

Во вкладке Connectivity выберем любой I2C, например I2C2,  и вместо Disable выберем I2C, тем самым включив интерфейс. Станет доступно окно Configuration для настройки интерфейса.
Так как данный микроконтроллер настраивается как Slave, необходимо задать адрес, к которому будет обращаться Master для чтения данных. Поэтому во вкладке Configurations -> Parameter Setting 
в поле Primary Slave addres введём адрес, например 10 (адрес записан в шестнадцатиричной системе счисления). Далее в Configuration NVIC Setting включим I2C2 event interrupt, тем самым включив прерывания, необходимые 
для передачи данных по прерыванию.

![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/e8b9e021-7826-4d39-b617-7e0d98e16db9)


В интерфейсе I2C линии SDA и SCL должны быть обязательно притянуты к питанию. Это можно сделать во вкладке System core -> GPIO. Выбрав по отдельности каждый пин, в поле GPIO Pull-up/Pull-down выберем Pull-up.

Настройка Slave устройства готова, далее во вкладке Project Manager необходимо задать имя проекта,среду разработки и нажать кнопку generate code.

Настройка Master отличается тем, что также подключается интерфейс SPI и настраиваются необходимые пины для микроконтроллера.

![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/76e64f12-57a0-46b1-93b4-3d200fc2b527)

Далее напишем код для Slave устройства. Разберём код программы по частям. Первая часть изображена ниже.

```
1.	   for (int i =0; i<16;i++){
2.		  data_11[i] =0xff;
3.		  data_10[i] =0xff;
4.		  data_01[i] =0xff;
5.		  data_00[i] =0xff;
6.	   }
7.	   w = sqrt(1-pow(psi,2))/T;
8.	   a = psi/T;
```

Здесь происходит начальная инициализация массивов данных, которые будут отправляться на матрицу и расчёт некоторых значений, используемых в формуле расчёта переходного процесса.
Далее рассмотрим код, выполняемые в бесконечном цикле while.

```
9.	while (1) {
10.	    btn = HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin);
11.	    if (btn) {
12.	        pressed_flag = 1;
13.	        imp_time = time;
14.	    }
15.	 
16.	    h = (k * (1 - pow(e, -psi * time / T) * (cos(w * time) + (psi / sqrt(1 - pow(psi, 2))) * sin(w * time)))) +
17.	        pressed_flag * (k / 1.7 * ((w + pow(a, 2)) / w) * sin(w * (time - imp_time)) * pow(e, -a * (time - imp_time))); // расчёт значение переходной функции
18.	    hk = round(h / step_h) * step_h; // квантование  значений функции
19.	    tk = round(time / step_time) * step_time; // квантование  времени

```
 В переменную btnState считывается состояние кнопки для учёта реакции переходного процесса на импульс, генерируемые нажатием кнопки. 
 Далее рассчитывается значение переходного процесса, который зависит от  переменной времени time, увеличивающейся каждый цикл.  
 При нажатии кнопки к переходному процессу прибавляется значения реакции на импульс.

 Далее выполняется квантование  времени и значения функции с шагом step_h и stem_time.

 После этого выполняется участок кода для записи значений в массивы данных, которые отправляются на матрицу. 
 В условии выполняется проверка равенства предыдущих и текущих квантованных значений для того, чтобы избежать повторяемость одних и тех же значений,
 не несущих полезной информации.

 Данные записываются в 4 массива по 16 байт, каждый из которых отправляется на матрицу в зависимости от линий A и B. Таким образом, для управления всеми светодиодами необходимо отправить 64 байта.
 Запись в массивы можно представить при помощи иллюстрации.

 ![primerzapisi](https://github.com/BorisKomarov/transition-process-on-the-LED-matrix-P10/assets/151782169/f75fa47f-b708-4f77-a908-9956e9043631)

Для записи данных для  квантованных значений рассчитывается номер строки и колонки, как будто данные записываются в двумерный массив 16x32 элемента, имитирующий саму светодиодную матрицу. 
Номера колонки и строки рассчитываются, исходя из шага квантования. В зависимости от значения текущей колонки формируется байт diodes_byte, в который записывается бит, 
где определено значение функции. Исходя из значения строки выбирается один из четырёх массивов, в который записывается данный байт. Далее, также используя значение col и row,
рассчитывается позиция конкретного байта, в который при помощи операции «&=» значение этого байта обновляется без стирания уже имеющейся в нём информации. 
Таким образом, формируются массивы данных для каждой группы светодиодов, зависящей от значений A и B. Данный код выполняется, пока по оси времени не заполнится вся матрица,
что реализуется использованием условия «if(col<=31)». Описываемый фрагмент кода представлен ниже.

```
20.	     if (tk != temp_tk || hk != temp_hk) {
21.	        temp_tk = tk;
22.	        temp_hk = hk;
23.	        col = round(tk / step_time);
24.	        row = round(hk / step_h);
25.	        diodes_byte = ~(mask >> (col % 8));
26.	 
27.	        if (col <= 31) {
28.	            if (row % 4 == 0) {
29.	                data_11[4 * (col / 8) + row / 4] &= diodes_byte;
30.	            } else if (row % 4 == 1) {
31.	                data_01[4 * (col / 8) + row / 4] &= diodes_byte;
32.	            } else if (row % 4 == 2) {
33.	                data_10[4 * (col / 8) + row / 4] &= diodes_byte;
34.	            } else if (row % 4 == 3) {
35.	                data_00[4 * (col / 8) + row / 4] &= diodes_byte;
36.	            }
37.	        }

```

 После этого, для вывода следующих значений, выходящих за границы матрицы, все байты необходимо сдвинуть на 1 бит, а в свободную колонку записать новые значения битов, что реализовано ниже.  

 ```
38.	else {
39.	            for (int i = 0; i < 12; i++) {
40.	                shifted_bit = (data_11[i + 4] >> 7) & 1;
41.	                data_11[i] <<= 1;
42.	                data_11[i] |= shifted_bit;
43.	            }
44.	            for (int i = 0; i < 12; i++) {
45.	                shifted_bit = (data_10[i + 4] >> 7) & 1;
46.	                data_10[i] <<= 1;
47.	                data_10[i] |= shifted_bit;
48.	            }
49.	            for (int i = 0; i < 12; i++) {
50.	                shifted_bit = (data_01[i + 4] >> 7) & 1;
51.	                data_01[i] <<= 1;
52.	                data_01[i] |= shifted_bit;
53.	            }
54.	            for (int i = 0; i < 12; i++) {
55.	                shifted_bit = (data_00[i + 4] >> 7) & 1;
56.	                data_00[i] <<= 1;
57.	                data_00[i] |= shifted_bit;
58.	            }
 ```

Сдвиг реализуется следующим образом: пусть есть байт 1 и байт 2. Сначала вычисляется значение старшего бита «shifted_bit» байта 2. 
Далее байт 1 сдвигается на одно значение, а в его младший бит записывается старший бит байта 2. Данная операция выполняется для 12 байтов в массиве, фрагмент кода алгоритма представлен ниже.

```
59.	            for (int i = 0; i < 3; i++) {
60.	                data_11[12 + i] <<= 1;
61.	                data_11[12 + i] |= 0b00000001;
62.	            }
63.	            for (int i = 0; i < 3; i++) {
64.	                data_10[12 + i] <<= 1;
65.	                data_10[12 + i] |= 0b00000001;
66.	            }
67.	            for (int i = 0; i < 3; i++) {
68.	                data_01[12 + i] <<= 1;
69.	                data_01[12 + i] |= 0b00000001;
70.	            }
71.	            for (int i = 0; i < 3; i++) {
72.	                data_00[12 + i] <<= 1;
73.	                data_00[12 + i] |= 0b00000001;
74.	            }
```

Для последних четырёх байт выполняется изменённый код, так как в данные байты необходимо также записать новые значения в зависимости от переменной diodes_byte.

```
75.	            if (row % 4 == 0) {
76.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
77.	                shifted_bit |= 0b11111110;
78.	                data_11[12 + row / 4] &= shifted_bit;
79.	            }
80.	            if (row % 4 == 1) {
81.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
82.	                shifted_bit |= 0b11111110;
83.	                data_01[12 + row / 4] &= shifted_bit;
84.	            }
85.	            if (row % 4 == 2) {
86.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
87.	                shifted_bit |= 0b11111110;
88.	                data_10[12 + row / 4] &= shifted_bit;
89.	            }
90.	            if (row % 4 == 3) {
91.	                shifted_bit = ((diodes_byte << col % 8) >> 7) & 1;
92.	                shifted_bit |= 0b11111110;
93.	                data_00[12 + row / 4] &= shifted_bit;
94.	            }
95.	        }
96.	    }
97.	}
98.	time+=0.01;
```
Далее необходимо отправить данные на плату Master. Для этого формируется пакет данных в 64 байта, который отправляется функцией  HAL_I2C_Slave_Transmit_IT.

```
for(int i = 0; i<16;i++){
99.			  fulldata[i] = data_00[i];
100.		  }
101.		  for(int i = 0; i<16;i++){
102.			  fulldata[16+i] = data_01[i];
103.		  }
104.		  for(int i = 0; i<16;i++){
105.			  fulldata[32+i] = data_10[i];
106.		  }
107.		  for(int i = 0; i<16;i++){
108.			  fulldata[48+i] = data_11[i];
109.		  }
110.		  HAL_I2C_Slave_Transmit_IT(&hi2c2, &fulldata, 64);

```

Разберём также код для Master устройства. Сначала данные принимаются функцией HAL_I2C_Slave_Recieve_IT.

```
HAL_I2C_Slave_Recieve_IT(&hi2c2,10<<1, &fulldata, 64);
2.		  for(int i = 0; i<16;i++){
3.			  data_00[i] = fulldata[i];
4.		  }
5.		  for(int i = 0; i<16;i++){
6.			  data_01[i] = fulldata[16+i];
7.		  }
8.		  for(int i = 0; i<16;i++){
9.			  data_10[i] = fulldata[32+i];
10.		  }
11.		  for(int i = 0; i<16;i++){
12.			  data_11[i] = fulldata[48+i];
13.	        }

```
Далее данные отправляются на матрицу.

```
// смена значений A и B
15.	    A = (AB_counter % 2 == 0) ? 1 : 0;
16.	    B = (AB_counter / 2 % 2 == 0) ? 1 : 0;
17.	    AB_counter = (AB_counter + 1) % 4;
18.	 
19.	    HAL_GPIO_WritePin(NOE_GPIO_Port, NOE_Pin, GPIO_PIN_RESET);
20.	 
21.	    HAL_GPIO_WritePin(A_GPIO_Port, A_Pin, A);
22.	    HAL_GPIO_WritePin(B_GPIO_Port, B_Pin, B);
23.	 
24.	    // Отправка данных в зависимости от уровней A и B
25.	    if (A == 1 && B == 1) {
26.	        HAL_SPI_Transmit(&hspi2, &data_11, 16, 10);
27.	    }
28.	    if (A == 0 && B == 1) {
29.	        HAL_SPI_Transmit(&hspi2, &data_01, 16, 10);
30.	    }
31.	    if (A == 1 && B == 0) {
32.	        HAL_SPI_Transmit(&hspi2, &data_10, 16, 10);
33.	    }
34.	    if (A == 0 && B == 0) {
35.	        HAL_SPI_Transmit(&hspi2, &data_00, 16, 10);
36.	    }
37.	 
38.	    HAL_GPIO_WritePin(SCLK_GPIO_Port, SCLK_Pin, GPIO_PIN_RESET);
39.	    HAL_GPIO_WritePin(SCLK_GPIO_Port, SCLK_Pin, GPIO_PIN_SET);
40.	 
41.	    HAL_GPIO_WritePin(NOE_GPIO_Port, NOE_Pin, GPIO_PIN_SET);
42.	    HAL_Delay(1);

```

Таким образом, с помощью данных праграмм можно реализовать вывод графика переходного процесса на матрицу, при этом расчёт происходит на плате Slave, а вывод осуществляется при помощи платы Master.

# Подключение

Для подключения плат и матрицы можно воспользоваться следующей схемой.

![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/f9556383-a210-4df2-9cfc-b12a705c17fe)

В качестве Master устройства выступает плата STM32F303VCT6. Линии SDA и SCL плат подключаются между собой джамперами. Далее необходимо подключить матрицу. Распиновка входа матрицы показана ниже (любой пин GND подключается в пину GND платы, ENABLE = nOE)

![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/b7d6f6a2-0089-47b3-a2ec-46478c9b795b)

Для более удобного подключения используется шлейф, один конец которого подключается во вход матрицы, а к другому концу подключаются джамперы с платы. Пример подключения показан ниже

![image](https://github.com/BorisKomarov/Connection-of-STM32-I2C-boards-with-graph-output-to-an-LED-matrix/assets/151782169/127b51e0-5f6c-4085-b608-0b280193c5db)















